Below is a comprehensive blueprint for your DevOps Ghostwriter project. This 
documentation is organized into technical segments to serve as your projectâ€™s "Source of 
Truth" during the hackathon. 
ğŸ“„ Project Overview: "DevOps Ghostwriter" 
Concept: An autonomous, multi-agent AI system that serves as a virtual DevOps engineer. It 
monitors GitHub Pull Requests (PRs), performs deep security audits, executes code in a 
sandbox to verify logic, and automatically drafts documentationâ€”all while providing full 
observability via Weights & Biases. 
ğŸ›  Technical Stack 
â—  Frontend: React.js (Vite), Tailwind CSS, Socket.io-client (for real-time agent logs). 
â—  Backend (Orchestration): Node.js, Express.js, MongoDB (Audit history & status 
tracking). 
â—  Agent Engine: Python 3.10+, FastAPI, Google Agent Development Kit (ADK). 
â—  AI Brain: Gemini 1.5 Pro (Reasoning/Security) & Gemini 1.5 Flash (Tests/Linting). 
â—  Observability: Weights & Biases (W&B) Weave (Tracing & Eval). 
ğŸ—º Frontend: Routes & UI Structure 
Path  Component  Description 
/  Dashboard  Grid view of repositories; 
displays "Health Scores" 
for recent PRs. 
/repo/:id  RepoDetails  Timeline of all AI-reviewed 
PRs and security trends 
over time. 
/audit/:prId  AuditCenter  The Main Demo Page: 
Real-time terminal showing 
agent thoughts and final 
verdict. 
/trace/:traceId  Observability  An embedded W&B Weave 
iframe showing the full 
reasoning trace. 
âš™ Backend: Logic & API Routes 
The backend acts as a bridge between GitHub and your AI Agents. 
Node.js Routes (The Bridge) 
â—  POST /api/webhook/github: Entry point for GitHub PR events. Validates signatures and 
saves PR data to MongoDB. 
â—  GET /api/audits/:prId: Fetches the status and results of a specific AI review. 
â—  GET /api/stats: Aggregates "Bugs Caught" and "Tokens Saved" for the dashboard. 
Python FastAPI (The Agent Engine) 
â—  POST /analyze: Triggered by Node.js. Initializes the ADK session. 
â—  GET /health: Checks connectivity to Gemini and W&B. 
ğŸ¤– AI Agent Workflow (Google ADK) 
Using the Parallel Fan-Out/Gather Pattern, your agents collaborate as follows: 
1.  Orchestrator Agent (The Manager): Receives the PR diff. It creates a shared 
session.state and spawns three sub-agents. 
2.  Security Auditor (Specialist): Scans the diff for hardcoded secrets, SQL injection, or 
vulnerable dependencies. 
3.  Runtime Validator (Tool User): 
â—‹  Uses Gemini's native Code Execution tool. 
â—‹  Writes a temporary test script based on the PR changes. 
â—‹  Executes it in the ADK sandbox and reports if it crashes. 
4.  Ghostwriter (The Synthesizer): * Gathers findings from the state. 
â—‹  Writes a professional GitHub comment: "âœ… Logic Passed | âš  1 Security Risk Found | 
ğŸ“ Updated README." 
ğŸ“Š W&B Weave Implementation 
To win the "Innovative Use of W&B" category: 
â—  Instrumentation: Decorate every agent function with @weave.op(). 
â—  Live Tracing: Capture the exact "Thought" before a tool is called. 
â—  Evaluations: Create a dataset of "Known Buggy PRs." Run your agent against them and 
use W&B to visualize the Success Rate vs. Latency. 
ğŸš€ Execution Roadmap (Priority Tasks) 
1.  P1 (Core): Connect Node.js to a GitHub Webhook and forward the payload to a simple 
Python "Echo" agent. 
2.  P2 (Intelligence): Build the ADK hierarchy (Manager + 1 Specialist). Integrate W&B 
Weave for tracing. 
3.  P3 (Polish): Build the React "Live Log" UI using Socket.io and embed the W&B Trace 
dashboard. 
Build a multi-agent app with ADK and Gemini 
This video is essential because it demonstrates how to orchestrate multiple specialized agents 
using Google's ADK, which is the core framework for your DevOps Ghostwriter's "intelligence" 
layer. 
 
